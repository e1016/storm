{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./dist/storm.js"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Collection","json","str","JSON","parse","string","obj","stringify","undefined","localStorage","StormCollection","conf","this","storageType","storeOnSession","callbackStack","save","find","erase","update","Error","storeReference","ob","data","forEach","callback","getItem","push","setItem","conditions","matchCounter","store","keeped","erased","conditionsLength","keys","length","el","conKey","removeItem","polluteCollection","__proto__","last","first","baseFinderMethod","values","nod","collection","storeCollection","refactoredObject","JsonKey","split","nodMirror","indexOf","result","findOne","set","where","flag","whereLength","setterLength","w","data_el","indx","findSorted","order","orderer","parmOrder","match","replace","trim","sortedResult","sort","b","exists","on","type"],"mappings":"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","file":"./storm.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\n/**\n* Eliseo Geraldo · <e10169610@gmail.com>\n* Storage Relational-Object Mapping\n* 1.3.0 beta · 2018-06-30\n* lic · MIT\n*/\n\n(function (factory) {\n\n  // checking for exports avalible\n  if (typeof module !== 'undefined' && module.exports) {\n    // export Collection\n    module.exports.Collection = factory()\n  } else {\n    // else add to root variable\n    window['Collection'] = factory()\n  }\n\n}) (function () {\n\n  // checking for native localStorage support\n  var support = function support () {\n    return localStorage !== undefined && localStorage !== null\n  }\n\n  /*\n  * Methods for convert JSON <-> String\n  */\n  var json = function (str) {\n    return JSON.parse(str)\n  }\n\n  var string = function (obj) {\n    return JSON.stringify(obj)\n  }\n\n  if (!support) throw '[Store Error]: local and session storage is not supported!'\n\n  // initializing Store class model\n  var StormCollection = function (str, conf) {\n\n    /*\n    * Config collection for sessionStorage or localStorage\n    */\n    this.storageType = (conf && conf.storeOnSession) ? 'sessionStorage' : 'localStorage'\n    /*\n    * callback stacks\n    */\n    this.callbackStack = { save: [], find: [], erase: [], update: [] }\n\n    if (!str && typeof str !== 'string') throw new Error (\n      '[Store Error]: Collection reference is not defined ' +\n      'Collection constructor expects a String for use as ' +\n      'a referenc in ' + conf.storeOnSession ? 'session' : 'local' + 'Storage'\n    )\n    // all is fine\n    this.storeReference = str\n  }\n\n  // Save method\n  StormCollection.prototype.save = function (ob) {\n    // dispatch save events\n    this.callbackStack.save.forEach (function (callback) { callback(ob) })\n\n    var data\n\n    // check for correct type of parameter\n    // it should be an object\n    if  (typeof ob !== 'object') throw '[Store Error]: \"save\" method expect a JSON'\n\n    // check if register exists\n    if ( data = json(window[this.storageType].getItem(this.storeReference)) ) {\n      data.push(ob)\n      window[this.storageType].setItem (\n        this.storeReference,\n        string(data)\n      )\n    } else {\n      // insert data for first time\n      data = []\n      data.push(ob)\n      window[this.storageType].setItem (\n        this.storeReference,\n        string(data)\n      )\n    }\n  }\n\n  // Delete method\n  StormCollection.prototype.erase = function (conditions) {\n\n    if (conditions) {\n      var store = json(window[this.storageType].getItem(this.storeReference))\n      var matchCounter\n      var keeped = [], erased = []\n      var conditionsLength = Object.keys(conditions).length\n\n      store.forEach(function (el) {\n        matchCounter = 0\n        for (var conKey in conditions)\n          if (conditions[conKey] === el[conKey]) matchCounter++\n\n        if (conditionsLength === matchCounter)\n          erased.push(el)\n        else\n          keeped.push(el)\n      })\n      window[this.storageType].setItem(this.storeReference, string(keeped))\n      return {\n        keeped: keeped,\n        erased: erased\n      }\n    } else {\n      window[this.storageType].removeItem(this.storeReference)\n    }\n\n\n    this.callbackStack.erase.forEach(function (callback) { callback() })\n  }\n\n  var polluteCollection = function (obj) {\n    obj.__proto__.last = function () { return this[obj.length - 1] }\n    obj.__proto__.first = function () { return this[0] }\n  }\n\n  /**\n  * function baseFinderMethod returns\n  * entire collection, based on some parameters\n  *\n  * @param values is used for define filter\n  * collection, for example, find user where age\n  * is 23, or name is \"Juan\"\n  *\n  * @param nod who fields we get, for example,\n  * get name, age and _id\n  *\n  * @param collection contains a reference\n  * for manipulate data in storage\n  * localStorage.getItem(collection)\n  *\n  * @param storageType works for switch between\n  * localStorage and sessionStorage\n  */\n\n  var baseFinderMethod = function (values, nod, collection, storageType) {\n    var data\n    var storeCollection = []\n    var refactoredObject = {}\n\n    if (values) {\n\n      if (typeof values !== 'object') throw '[Store Error]: \"find\" method expect a JSON'\n      data = json(window[storageType].getItem(collection))\n\n      // if the node is defined, it responds\n      // only with the requested nodes\n      if (nod && typeof nod === 'string') {\n        for (var JsonKey in values) {\n          data.forEach(function (el) {\n            if (el[JsonKey] == values[JsonKey]) {\n              nod.split(/ +/g).forEach(function (nodMirror) {\n                refactoredObject[nodMirror] = el[nodMirror]\n              })\n              storeCollection.push(refactoredObject)\n              refactoredObject = {}\n            }\n          })\n        }\n        // else, request all nodes\n      } else {\n         for (var JsonKey in values) {\n            data.forEach(function (el) {\n            if (el[JsonKey] == values[JsonKey] && (storeCollection.indexOf(el) < 0)) {\n              storeCollection.push(el)\n            }\n          })\n        }\n      }\n\n      if (storeCollection.length) polluteCollection(storeCollection)\n      return storeCollection\n    } else {\n\n      storeCollection = json(window[storageType].getItem(collection))\n      if (storeCollection) polluteCollection(storeCollection)\n      return storeCollection\n    }\n  }\n\n  // Find method\n  StormCollection.prototype.find = function (values, nod) {\n    var result = baseFinderMethod(values, nod, this.storeReference, this.storageType)\n    this.callbackStack.find.forEach(function (callback) { callback(result) })\n    return result\n  }\n\n  // Find one method\n  StormCollection.prototype.findOne = function (values, nod) {\n    var result = (baseFinderMethod(values, nod, this.storeReference, this.storageType))[0]\n    this.callbackStack.find.forEach(function (callback) { callback(result) })\n    return result\n  }\n\n  // update method\n  StormCollection.prototype.update = function (ob) {\n\n    if (!ob.set || !ob.where) throw '[Store Error]: \"set\" or \"where\" node missing'\n\n    if (\n      typeof ob.where !== 'object' ||\n      typeof ob.set !== 'object'\n    ) throw '[Store Error]: \"where\" or \"set\" node expects objects'\n\n    this.callbackStack.update.forEach (function (callback) { callback(ob) })\n\n    var data\n    var rules = []\n    var setterLength = 0\n    var whereLength = 0\n    var flag\n\n    // checking for all avalible setters\n    for (s in ob.set) setterLength++\n\n    // check for all conditions\n    for (w in ob.where) whereLength++\n\n    if (data = json(window[this.storageType].getItem(this.storeReference))) {\n      data.forEach(function(data_el, indx) {\n        flag = 0 // <- resetting flag to 0\n        // checking for coincidences in each of stored object\n        // conditions\n        for (w in ob.where) flag += (ob.where[w] === data_el[w]) ? 1 : 0\n        // nodes that will be returned\n        if (flag === whereLength) {\n          for (s in ob.set) data[indx][s] = ob.set[s]\n        }\n      })\n      // saving updated object\n      window[this.storageType].setItem (\n        this.storeReference,\n        string(data)\n      )\n    } else {\n      throw new Error('[Store Error]: has been ocurred an error trying to get data from ' + this.storeReference)\n    }\n  }\n\n  // Find and Sort method\n  StormCollection.prototype.findSorted = function (order) {\n    var result, orderer, parmOrder\n    if (typeof order !== 'string') throw '[Store Error]: Sort parameter should be String type'\n    if (!(orderer = order.match(/[<|>]/)[0])) throw '[Store Error]: Error processing'\n\n    parmOrder = order.replace(/[<|>]/, '').trim()\n    result = baseFinderMethod(undefined, undefined, this.storeReference, this.storageType)\n\n    var sortedResult = result.sort(function(a, b) {\n      return (orderer === '<')\n      ? a[parmOrder] < b[parmOrder]\n      : a[parmOrder] > b[parmOrder]\n    })\n\n    this.callbackStack.find.forEach(function (callback) {\n      callback(sortedResult)\n    })\n\n    return sortedResult\n  }\n\n  StormCollection.prototype.exists = function () {\n    return !!window[this.storageType].getItem(this.storeReference)\n  }\n\n  StormCollection.prototype.on = function (type, callback) {\n    if (typeof callback !== 'function') throw new Error ('onSave methods expects a function')\n    if (['find', 'save', 'erase', 'update'].indexOf(type) < 0) throw new Error (type + ' is invalid event')\n\n    this.callbackStack[type].push(callback)\n  }\n  return StormCollection\n})\n"],"sourceRoot":""}